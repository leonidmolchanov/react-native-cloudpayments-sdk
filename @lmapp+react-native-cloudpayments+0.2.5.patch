diff --git a/node_modules/@lmapp/react-native-cloudpayments/android/build.gradle b/node_modules/@lmapp/react-native-cloudpayments/android/build.gradle
index 3d570b2..2b1d10a 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/android/build.gradle
+++ b/node_modules/@lmapp/react-native-cloudpayments/android/build.gradle
@@ -77,8 +77,10 @@ dependencies {
   implementation "com.facebook.react:react-native:+"
   implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
 
-  // CloudPayments SDK 2.1.1 (требует Kotlin 2.2.0)
-  implementation 'ru.cloudpayments.gitpub.integrations.sdk:cloudpayments-android:2.1.1'
+  // ПАТЧ: Используем локальный пропатченный CloudPayments SDK без Compose
+  // Вместо Maven зависимости используем локальный модуль
+  // implementation 'ru.cloudpayments.gitpub.integrations.sdk:cloudpayments-android:2.1.1'
+  implementation project(':cloudpayments-sdk-patched')
 
   // Google Pay (опционально)
   implementation 'com.google.android.gms:play-services-wallet:18.1.2'
diff --git a/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/CloudPaymentsEventEmitter.kt b/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/CloudPaymentsEventEmitter.kt
index 1223676..c8a57a9 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/CloudPaymentsEventEmitter.kt
+++ b/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/CloudPaymentsEventEmitter.kt
@@ -15,7 +15,6 @@ import com.facebook.react.modules.core.DeviceEventManagerModule
  * @since 1.0.0
  */
 class CloudPaymentsEventEmitter(private val reactContext: ReactApplicationContext) {
-    
     /**
      * Отправка произвольного события в JavaScript
      *
@@ -29,8 +28,7 @@ class CloudPaymentsEventEmitter(private val reactContext: ReactApplicationContex
                     .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
                     .emit(eventName, params)
             } catch (e: Exception) {
-                // Критическая ошибка - оставляем для отладки
-                android.util.Log.e("CloudPayments", "Failed to send event: ${e.message}", e)
+                // Критическая ошибка - игнорируем
             }
         }
     }
@@ -59,10 +57,18 @@ class CloudPaymentsEventEmitter(private val reactContext: ReactApplicationContex
             
             // Для транзакций добавляем дополнительные поля
             if (action == EPaymentFormAction.TRANSACTION.rawValue) {
-                statusCode?.let { putBoolean(EResponseKeys.STATUS_CODE.rawValue, it) }
-                transactionId?.let { putDouble(EResponseKeys.TRANSACTION_ID.rawValue, it.toDouble()) }
-                message?.let { putString(EResponseKeys.MESSAGE.rawValue, it) }
-                errorCode?.let { putString(EResponseKeys.ERROR_CODE.rawValue, it) }
+                statusCode?.let { 
+                    putBoolean(EResponseKeys.STATUS_CODE.rawValue, it) 
+                }
+                transactionId?.let { 
+                    putDouble(EResponseKeys.TRANSACTION_ID.rawValue, it.toDouble()) 
+                }
+                message?.let { 
+                    putString(EResponseKeys.MESSAGE.rawValue, it) 
+                }
+                errorCode?.let { 
+                    putString(EResponseKeys.ERROR_CODE.rawValue, it) 
+                }
             }
         }
         
@@ -71,6 +77,7 @@ class CloudPaymentsEventEmitter(private val reactContext: ReactApplicationContex
     
     /**
      * Отправка события успешной транзакции
+     * ПАТЧ: Формат события должен совпадать с iOS версией
      */
     fun sendTransactionSuccess(transactionId: Long, message: String? = null) {
         sendPaymentFormEvent(
@@ -83,6 +90,7 @@ class CloudPaymentsEventEmitter(private val reactContext: ReactApplicationContex
     
     /**
      * Отправка события ошибки транзакции
+     * ПАТЧ: Формат события должен совпадать с iOS версией
      */
     fun sendTransactionError(message: String, errorCode: String? = null) {
         sendPaymentFormEvent(
@@ -95,11 +103,11 @@ class CloudPaymentsEventEmitter(private val reactContext: ReactApplicationContex
     
     /**
      * Отправка события отмены платежа
-     * ИСПРАВЛЕНО: теперь отправляет специальное событие отмены, а не ошибки
+     * ПАТЧ: Отправляем событие transaction с statusCode=false, как в iOS onPaymentClosed
      */
     fun sendTransactionCancelled(message: String? = null) {
         sendPaymentFormEvent(
-            action = "cancelled", // Специальное действие для отмены
+            action = EPaymentFormAction.TRANSACTION.rawValue, // ПАТЧ: Используем transaction, как в iOS
             statusCode = false,
             message = message ?: EDefaultMessages.PAYMENT_CANCELLED_BY_USER.rawValue,
             errorCode = ECloudPaymentsError.PAYMENT_FAILED.rawValue
diff --git a/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/CloudpaymentsSdkModule.kt b/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/CloudpaymentsSdkModule.kt
index a979d21..3368863 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/CloudpaymentsSdkModule.kt
+++ b/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/CloudpaymentsSdkModule.kt
@@ -1,7 +1,10 @@
 package com.cloudpaymentssdk
 
 import android.app.Activity
+import android.app.Application
 import android.content.Intent
+import android.os.Handler
+import android.os.Looper
 import androidx.fragment.app.FragmentActivity
 import com.facebook.react.bridge.ActivityEventListener
 import com.facebook.react.bridge.Arguments
@@ -22,11 +25,12 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
   private var pendingPromise: Promise? = null
   private var isProcessingResult = false // Защита от повторной обработки
 
-  // НОВОЕ: Переменные для отслеживания последней ошибки
-  private var lastPaymentError: String? = null
-  private var lastPaymentErrorCode: String? = null
+  // ПАТЧ: Упрощенные переменные (не используем сложную логику с сохранением ошибок)
   private var hasActivePaymentAttempt = false
-  private var paymentStartTime: Long = 0L
+  
+  // ПАТЧ: Флаг для отслеживания, нужно ли отправить didDisplay
+  private var shouldSendDidDisplay = false
+  private var lifecycleCallback: Application.ActivityLifecycleCallbacks? = null
 
   companion object {
     const val NAME = EModuleNames.CLOUDPAYMENTS_SDK
@@ -35,11 +39,13 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
      * Helper функция для получения статуса транзакции с поддержкой новых API
      * Улучшенная версия с обработкой ошибок десериализации
      */
-    private fun getTransactionStatus(data: Intent?): CloudpaymentsSDK.TransactionStatus? {
-      if (data == null) return null
+    fun getTransactionStatus(data: Intent?): CloudpaymentsSDK.TransactionStatus? {
+      if (data == null) {
+        return null
+      }
 
       return try {
-        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
+        val status = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
           data.getSerializableExtra(
             CloudpaymentsSDK.IntentKeys.TransactionStatus.name,
             CloudpaymentsSDK.TransactionStatus::class.java
@@ -49,11 +55,10 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
           val serializable = data.getSerializableExtra(CloudpaymentsSDK.IntentKeys.TransactionStatus.name)
           serializable as? CloudpaymentsSDK.TransactionStatus
         }
+        status
       } catch (e: ClassCastException) {
-        // Проблема с приведением типов - логируем и возвращаем null
         null
       } catch (e: Exception) {
-        // Любая другая ошибка при извлечении статуса
         null
       }
     }
@@ -61,6 +66,43 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
 
   init {
     reactApplicationContext.addActivityEventListener(this)
+    // ПАТЧ: Регистрируем lifecycle callback для отслеживания PaymentActivity
+    registerLifecycleCallback()
+  }
+  
+  /**
+   * ПАТЧ: Регистрация lifecycle callback для отслеживания, когда PaymentActivity действительно отобразилась
+   */
+  private fun registerLifecycleCallback() {
+    val application = reactApplicationContext.currentActivity?.application as? Application
+    if (application != null) {
+      lifecycleCallback = object : Application.ActivityLifecycleCallbacks {
+        override fun onActivityResumed(activity: Activity) {
+          // ПАТЧ: Проверяем имя класса через строку, так как PaymentActivity является internal
+          val activityClassName = activity.javaClass.name
+          if (activityClassName == "ru.cloudpayments.sdk.ui.PaymentActivity" && shouldSendDidDisplay) {            shouldSendDidDisplay = false
+            eventEmitter.sendFormDidDisplay()
+          }
+        }
+        
+        override fun onActivityCreated(activity: Activity, savedInstanceState: android.os.Bundle?) {}
+        override fun onActivityStarted(activity: Activity) {}
+        override fun onActivityPaused(activity: Activity) {}
+        override fun onActivityStopped(activity: Activity) {}
+        override fun onActivitySaveInstanceState(activity: Activity, outState: android.os.Bundle) {}
+        override fun onActivityDestroyed(activity: Activity) {}
+      }
+      application.registerActivityLifecycleCallbacks(lifecycleCallback)    } else {    }
+  }
+  
+  /**
+   * ПАТЧ: Отмена регистрации lifecycle callback
+   */
+  private fun unregisterLifecycleCallback() {
+    val application = reactApplicationContext.currentActivity?.application as? Application
+    lifecycleCallback?.let { callback ->
+      application?.unregisterActivityLifecycleCallbacks(callback)
+      lifecycleCallback = null    }
   }
 
   override fun getName(): String {
@@ -225,25 +267,24 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
       // Сохраняем Promise для обработки результата
       pendingPromise = promise
 
-      // Сбрасываем флаги для нового платежа
+      // ПАТЧ: Сбрасываем флаги для нового платежа
       isProcessingResult = false
-
-      // НОВОЕ: Очищаем предыдущие ошибки при начале нового платежа
-      lastPaymentError = null
-      lastPaymentErrorCode = null
       hasActivePaymentAttempt = true
-      paymentStartTime = System.currentTimeMillis()
 
       // Создаем конфигурацию платежа
       val configuration = PaymentDataConverter.createPaymentConfiguration(currentPublicId, paymentData)
 
-      // Отправляем события
+      // Отправляем событие willDisplay
       eventEmitter.sendFormWillDisplay()
-      eventEmitter.sendFormDidDisplay()
+
+      // ПАТЧ: Устанавливаем флаг, что нужно отправить didDisplay когда Activity отобразится
+      shouldSendDidDisplay = true
 
       // Запускаем платежную форму напрямую
       CloudpaymentsSDK.getInstance().start(configuration, activity, EModuleNames.PAYMENT_REQUEST_CODE)
       
+      // ПАТЧ: didDisplay будет отправлен через lifecycle callback когда PaymentActivity.onResume() будет вызван
+
     } catch (e: Exception) {
       promise.reject(EAndroidSpecific.PAYMENT_FORM_ERROR, "Failed to present payment form: ${e.message}", e)
     }
@@ -275,12 +316,52 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
     }
 
     isProcessingResult = true
-
     val transactionStatus = getTransactionStatus(data)
-    val transactionId = data?.getLongExtra(CloudpaymentsSDK.IntentKeys.TransactionId.name, 0L) ?: 0L
-    val reasonCode = data?.getIntExtra(CloudpaymentsSDK.IntentKeys.TransactionReasonCode.name, 0) ?: 0
     
-    // НОВОЕ: Проверяем, есть ли URL с информацией об ошибке (например, из 3D Secure)
+    // ПАТЧ: Проверяем все возможные ключи для transactionId
+    val transactionIdKey = CloudpaymentsSDK.IntentKeys.TransactionId.name
+    val transactionId = try {
+      data?.getLongExtra(transactionIdKey, 0L) ?: 0L
+    } catch (e: Exception) {
+      try {
+        // Пробуем как Int
+        val intValue = data?.getIntExtra(transactionIdKey, 0) ?: 0
+        intValue.toLong()
+      } catch (e2: Exception) {
+        0L
+      }
+    }
+    
+    // ПАТЧ: Логируем все ключи из Intent для отладки
+    if (data != null) {
+      val extras = data.extras
+      if (extras != null) {
+        for (key in extras.keySet()) {
+          val value = extras.get(key)
+        }
+      }
+    }
+
+    // ПАТЧ: reasonCode может быть как String (старый SDK) так и Int (новый SDK)
+    // В старом SDK reasonCode передается как String (строка 615 PaymentActivity.kt),
+    // в новом SDK как Int. Нужно поддерживать оба варианта.
+    val reasonCode: Int = try {
+      // Сначала пробуем получить как Int (новый SDK)
+      val intValue = data?.getIntExtra(CloudpaymentsSDK.IntentKeys.TransactionReasonCode.name, 0) ?: 0
+      intValue
+    } catch (e: Exception) {
+      // Если не удалось получить как Int, пробуем как String (старый SDK)
+      try {
+        val reasonCodeString = data?.getStringExtra(CloudpaymentsSDK.IntentKeys.TransactionReasonCode.name)
+        val stringValue = reasonCodeString?.toIntOrNull() ?: 0
+        stringValue
+      } catch (e2: Exception) {
+        0
+      }
+    }
+
+    // ПАТЧ: Проверяем, есть ли URL с информацией об ошибке (например, из 3D Secure)
+    // Это обрабатывается через обычный flow с transactionStatus
     val dataString = data?.dataString
 
     if (dataString != null && dataString.contains("threeds/fail")) {
@@ -301,12 +382,14 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
             }
           }
 
+          // ПАТЧ: Обрабатываем через обычный flow - события отправятся автоматически
           eventEmitter.sendFormWillHide()
           handleFailedPayment(errorIntent)
           eventEmitter.sendFormDidHide()
 
-          // Очищаем Promise и сбрасываем флаги
-          pendingPromise = null
+          // Промис уже очищен в handleFailedPayment
+
+          // Сбрасываем флаги
           isProcessingResult = false
           hasActivePaymentAttempt = false
 
@@ -317,63 +400,71 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
       }
     }
 
-    // Отправляем события
+    // ПАТЧ: Отправляем событие willHide перед обработкой результата (как в iOS)
     eventEmitter.sendFormWillHide()
 
-    when (resultCode) {
-      Activity.RESULT_OK -> {
-        when (transactionStatus) {
-          CloudpaymentsSDK.TransactionStatus.Succeeded -> {
-            handleSuccessfulPayment(data)
-          }
-          CloudpaymentsSDK.TransactionStatus.Failed -> {
-            handleFailedPayment(data)
-          }
-          null -> {
-            // КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ: правильная обработка неизвестного статуса
-            // Если статус неизвестен, но resultCode = OK, проверяем наличие transactionId
+    // ПАТЧ: В старом SDK все методы вызывают setResult(RESULT_OK, ...), даже для ошибок
+    // Статус определяется по TransactionStatus в Intent, а не по resultCode
+    // Поэтому сначала проверяем transactionStatus, а не resultCode
+    when (transactionStatus) {
+      CloudpaymentsSDK.TransactionStatus.Succeeded -> {
+        // Успешный платеж - всегда обрабатываем как успех
+        handleSuccessfulPayment(data)
+      }
+      
+      CloudpaymentsSDK.TransactionStatus.Failed -> {
+        // Неудачный платеж - всегда обрабатываем как ошибку
+        handleFailedPayment(data)
+      }
+      
+      null -> {
+        // Если статус неизвестен, определяем по resultCode и другим признакам
+        when (resultCode) {
+          Activity.RESULT_OK -> {
+            // Если resultCode = OK, но статус неизвестен, проверяем наличие transactionId
             if (transactionId > 0L) {
               // Если есть transactionId, значит платеж прошел успешно
               handleSuccessfulPayment(data)
-            } else {
-              // Если нет transactionId, значит была ошибка
+            } else if (reasonCode > 0) {
+              // Если есть reasonCode, значит была ошибка
               handleFailedPayment(data)
+            } else {
+              // Если нет ни transactionId, ни reasonCode, считаем отменой
+              handleCancelledPayment()
             }
           }
-        }
-      }
           
-      Activity.RESULT_CANCELED -> {
-        when {
-          // Если статус явно указывает на неудачу - это ошибка
-          transactionStatus == CloudpaymentsSDK.TransactionStatus.Failed -> {
-            handleFailedPayment(data)
-          }
-          // Если есть код ошибки, но нет ID транзакции - это ошибка
-          reasonCode > 0 && transactionId <= 0L -> {
-            handleFailedPayment(data)
-          }
-          // Если есть ID транзакции - возможно успех (редкий случай)
-          transactionId > 0L -> {
-            handleSuccessfulPayment(data)
+          Activity.RESULT_CANCELED -> {
+            // Если resultCode = CANCELED, проверяем дополнительные признаки
+            when {
+              // Если есть код ошибки, но нет ID транзакции - это ошибка
+              reasonCode > 0 && transactionId <= 0L -> {
+                handleFailedPayment(data)
+              }
+              // Если есть ID транзакции - возможно успех (редкий случай)
+              transactionId > 0L -> {
+                handleSuccessfulPayment(data)
+              }
+              // Во всех остальных случаях - отмена пользователем
+              else -> {
+                handleCancelledPayment()
+              }
+            }
           }
-          // Во всех остальных случаях - отмена пользователем
+          
           else -> {
-            handleCancelledPayment()
+            // Любой другой код результата считаем ошибкой, а не отменой
+            handleFailedPayment(data)
           }
         }
       }
-
-      else -> {
-        // Любой другой код результата считаем ошибкой, а не отменой
-        handleFailedPayment(data)
-      }
     }
 
+    // ПАТЧ: Отправляем событие didHide после обработки результата (как в iOS paymentFormDidHide)
+    // Промис уже разрешен/реджекчен и очищен в handleSuccessfulPayment/handleFailedPayment/handleCancelledPayment
     eventEmitter.sendFormDidHide()
 
-    // Очищаем Promise и сбрасываем флаги
-    pendingPromise = null
+    // Сбрасываем флаги
     isProcessingResult = false
     hasActivePaymentAttempt = false
   }
@@ -385,127 +476,123 @@ class CloudpaymentsSdkModule(reactContext: ReactApplicationContext) :
     try {
       // Извлекаем данные транзакции из Intent используя ключи CloudPayments SDK
       val transactionId = data?.getLongExtra(CloudpaymentsSDK.IntentKeys.TransactionId.name, EDefaultValues.DEFAULT_TRANSACTION_ID) ?: EDefaultValues.DEFAULT_TRANSACTION_ID
-      val transactionStatus = data?.getSerializableExtra(CloudpaymentsSDK.IntentKeys.TransactionStatus.name) as? CloudpaymentsSDK.TransactionStatus
-      val reasonCode = data?.getIntExtra(CloudpaymentsSDK.IntentKeys.TransactionReasonCode.name, 0) ?: 0
-
-      // НОВОЕ: Очищаем сохраненные ошибки при успешном платеже
-      lastPaymentError = null
-      lastPaymentErrorCode = null
-      paymentStartTime = 0L
 
-      // Отправляем событие успешной транзакции
+      // ПАТЧ: Отправляем событие успешной транзакции (как в iOS onPaymentFinished)
       eventEmitter.sendTransactionSuccess(
         transactionId = transactionId,
         message = EDefaultMessages.PAYMENT_COMPLETED_SUCCESSFULLY.rawValue
       )
 
-      // Создаем результат для Promise - используем тот же формат что в iOS
+      // ПАТЧ: Создаем результат для Promise - используем тот же формат что в iOS
       val result = Arguments.createMap().apply {
         putBoolean(EResponseKeys.SUCCESS.rawValue, true)
         putDouble(EResponseKeys.TRANSACTION_ID.rawValue, transactionId.toDouble())
         putString(EResponseKeys.MESSAGE.rawValue, EDefaultMessages.PAYMENT_COMPLETED_SUCCESSFULLY.rawValue)
       }
 
-      pendingPromise?.resolve(result)
+      // ПАТЧ: Разрешаем промис на главном потоке (как в iOS DispatchQueue.main.async)
+      val promise = pendingPromise
+      Handler(Looper.getMainLooper()).post {
+        try {
+          promise?.resolve(result)
+          // ПАТЧ: Очищаем промис сразу после разрешения
+          pendingPromise = null
+        } catch (e: Exception) {
+          // Игнорируем ошибки разрешения промиса
+        }
+      }
     } catch (e: Exception) {
-      pendingPromise?.reject(EAndroidSpecific.SUCCESS_PROCESSING_ERROR, e.message, e)
+      val promise = pendingPromise
+      Handler(Looper.getMainLooper()).post {
+        promise?.reject(EAndroidSpecific.SUCCESS_PROCESSING_ERROR, e.message, e)
+        // ПАТЧ: Очищаем промис сразу после реджекта
+        pendingPromise = null
+      }
     }
   }
 
   /**
    * Обработка неудачного платежа
-   * ВАЖНО: Promise НЕ resolve-ается здесь сразу!
-   * Promise будет resolve-ан в handleCancelledPayment() когда пользователь закроет форму
+   * ПАТЧ: Теперь сразу реджектим промис, как в iOS версии
    */
   private fun handleFailedPayment(data: Intent?) {
     try {
       // Извлекаем данные об ошибке из Intent
       val transactionId = data?.getLongExtra(CloudpaymentsSDK.IntentKeys.TransactionId.name, EDefaultValues.DEFAULT_TRANSACTION_ID) ?: EDefaultValues.DEFAULT_TRANSACTION_ID
-      val transactionStatus = data?.getSerializableExtra(CloudpaymentsSDK.IntentKeys.TransactionStatus.name) as? CloudpaymentsSDK.TransactionStatus
-      val reasonCode = data?.getIntExtra(CloudpaymentsSDK.IntentKeys.TransactionReasonCode.name, 0) ?: 0
+
+      // ПАТЧ: reasonCode может быть как String (старый SDK) так и Int (новый SDK)
+      val reasonCode: Int = try {
+        val intValue = data?.getIntExtra(CloudpaymentsSDK.IntentKeys.TransactionReasonCode.name, 0) ?: 0
+        intValue
+      } catch (e: Exception) {
+        try {
+          val reasonCodeString = data?.getStringExtra(CloudpaymentsSDK.IntentKeys.TransactionReasonCode.name)
+          val stringValue = reasonCodeString?.toIntOrNull() ?: 0
+          stringValue
+        } catch (e2: Exception) {
+          0
+        }
+      }
 
       // Получаем код ошибки и сообщение на основе reasonCode
       val errorCode = PaymentDataConverter.getErrorCodeFromReasonCode(reasonCode)
       val errorMessage = PaymentDataConverter.getErrorMessage(reasonCode)
 
-      // ИСПРАВЛЕНО: Сохраняем информацию об ошибке для последующего использования
-      lastPaymentError = errorMessage
-      lastPaymentErrorCode = errorCode
-
-      // Отправляем событие ошибки транзакции (для уведомления UI)
+      // ПАТЧ: Отправляем событие ошибки транзакции (как в iOS onPaymentFailed)
       eventEmitter.sendTransactionError(
         message = errorMessage,
         errorCode = errorCode
       )
 
+      // ПАТЧ: Реджектим промис на главном потоке (как в iOS DispatchQueue.main.async)
+      val promise = pendingPromise
+      Handler(Looper.getMainLooper()).post {
+        try {
+          promise?.reject(
+            errorCode,
+            errorMessage,
+            null
+          )
+          // ПАТЧ: Очищаем промис сразу после реджекта
+          pendingPromise = null
+        } catch (e: Exception) {
+        }
+      }
     } catch (e: Exception) {
-      // Только в случае исключения resolve Promise с ошибкой
-      pendingPromise?.reject(EAndroidSpecific.FAILED_PROCESSING_ERROR, e.message, e)
+      // Только в случае исключения reject Promise с ошибкой
+      val promise = pendingPromise
+      Handler(Looper.getMainLooper()).post {
+        promise?.reject(EAndroidSpecific.FAILED_PROCESSING_ERROR, e.message, e)
+        // ПАТЧ: Очищаем промис сразу после реджекта
+        pendingPromise = null
+      }
     }
   }
 
   /**
    * Обработка отменённого платежа
+   * ПАТЧ: Теперь реджектим промис при отмене, как в iOS версии
    */
   private fun handleCancelledPayment() {
-    // НОВОЕ: Анализируем время работы формы
-    val paymentDuration = System.currentTimeMillis() - paymentStartTime
-
-    // УЛУЧШЕНО: Проверяем, была ли ошибка до закрытия формы
-    if (lastPaymentError != null && lastPaymentErrorCode != null) {
-      // Если была ошибка, отправляем событие ошибки, а не отмены
-      eventEmitter.sendTransactionError(
-        message = lastPaymentError!!,
-        errorCode = lastPaymentErrorCode!!
-      )
-
-      // Создаем результат с ошибкой для Promise
-      val result = Arguments.createMap().apply {
-        putBoolean(EResponseKeys.SUCCESS.rawValue, false)
-        putString(EResponseKeys.ERROR_CODE.rawValue, lastPaymentErrorCode!!)
-        putString(EResponseKeys.MESSAGE.rawValue, lastPaymentError!!)
-      }
-
-      pendingPromise?.resolve(result)
-    } else if (paymentDuration > 10000) {
-      // НОВАЯ ЛОГИКА: Если форма работала более 10 секунд, вероятно была ошибка 3D Secure
-      // Предполагаем, что была ошибка 3D Secure
-      val errorMessage = "3-D Secure авторизация не пройдена"
-      val errorCode = ECloudPaymentsError.PAYMENT_FAILED.rawValue
+    // ПАТЧ: Отправляем событие отмены (как в iOS onPaymentClosed)
+    eventEmitter.sendTransactionCancelled(EDefaultMessages.PAYMENT_CANCELLED_BY_USER.rawValue)
 
-      eventEmitter.sendTransactionError(
-        message = errorMessage,
-        errorCode = errorCode
-      )
-
-      // Создаем результат с ошибкой для Promise
-      val result = Arguments.createMap().apply {
-        putBoolean(EResponseKeys.SUCCESS.rawValue, false)
-        putString(EResponseKeys.ERROR_CODE.rawValue, errorCode)
-        putString(EResponseKeys.MESSAGE.rawValue, errorMessage)
-      }
-
-      pendingPromise?.resolve(result)
-    } else {
-      // Если ошибки не было, это действительно отмена пользователем
-      eventEmitter.sendTransactionCancelled(EDefaultMessages.PAYMENT_CANCELLED_BY_USER.rawValue)
-
-      // Создаем результат отмены для Promise
-      val result = Arguments.createMap().apply {
-        putBoolean(EResponseKeys.SUCCESS.rawValue, false)
-        putString(EResponseKeys.STATUS.rawValue, EPaymentResultValues.CANCELLED.rawValue)
-        putString(EResponseKeys.MESSAGE.rawValue, EDefaultMessages.PAYMENT_CANCELLED_BY_USER.rawValue)
-        putString(EResponseKeys.ERROR_CODE.rawValue, ECloudPaymentsError.PAYMENT_FAILED.rawValue)
+    // ПАТЧ: Реджектим промис на главном потоке при отмене (как в iOS DispatchQueue.main.async)
+    val cancelMessage = EDefaultMessages.PAYMENT_CANCELLED_BY_USER.rawValue
+    val promise = pendingPromise
+    Handler(Looper.getMainLooper()).post {
+      try {
+        promise?.reject(
+          ECloudPaymentsError.PAYMENT_FAILED.rawValue,
+          cancelMessage,
+          null
+        )
+        // ПАТЧ: Очищаем промис сразу после реджекта
+        pendingPromise = null
+      } catch (e: Exception) {
       }
-
-      pendingPromise?.resolve(result)
     }
-
-    // Очищаем сохраненные ошибки после обработки
-    lastPaymentError = null
-    lastPaymentErrorCode = null
     hasActivePaymentAttempt = false
-    paymentStartTime = 0L
   }
 
   /**
diff --git a/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/PaymentDataConverter.kt b/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/PaymentDataConverter.kt
index 24cbb81..8472f86 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/PaymentDataConverter.kt
+++ b/node_modules/@lmapp/react-native-cloudpayments/android/src/main/java/com/cloudpaymentssdk/PaymentDataConverter.kt
@@ -225,11 +225,9 @@ object PaymentDataConverter {
 
             // SDK 2.1.1: Receipt передается как Map<String, Any>
             if (paymentDataMap.hasKey(EPaymentConfigKeys.RECEIPT.rawValue)) {
-              Log.d("CloudPaymentsSDKPay", "RECEIPT key exists")
 
               val receiptMap = paymentDataMap.getMap(EPaymentConfigKeys.RECEIPT.rawValue)
                 val receiptJson = JSONObject(readableMapToJson(receiptMap))
-              Log.d("CloudPaymentsSDKPay", "receiptJson(before normalize) = ${receiptJson.toString(2)}")
 
               // Приводим ключи к ожидаемому формату API: items -> Items
                 if (receiptJson.has("items") && !receiptJson.has("Items")) {
@@ -244,7 +242,6 @@ object PaymentDataConverter {
                     jsonDataObject.put(EPaymentConfigKeys.CLOUDPAYMENTS.rawValue, newCloudPayments)
                     newCloudPayments
                 }
-              Log.d("CloudPaymentsSDKPay", "receiptJson(before normalize final) = ${receiptJson.toString(2)}")
 
 
                 cloudPaymentsJson.put(EPaymentConfigKeys.CUSTOMER_RECEIPT.rawValue, receiptJson)
diff --git a/node_modules/@lmapp/react-native-cloudpayments/ios/CloudpaymentsPaymentFormService.swift b/node_modules/@lmapp/react-native-cloudpayments/ios/CloudpaymentsPaymentFormService.swift
index 9abf29f..2e9443f 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/ios/CloudpaymentsPaymentFormService.swift
+++ b/node_modules/@lmapp/react-native-cloudpayments/ios/CloudpaymentsPaymentFormService.swift
@@ -11,6 +11,9 @@ public class CloudpaymentsPaymentFormService: NSObject {
     // Callbacks для React Native
     private var onPaymentSuccess: RCTResponseSenderBlock?
     private var onPaymentFailure: RCTResponseSenderBlock?
+    
+    // ПАТЧ: Сохраняем resolve и reject для вызова из onPaymentClosed (если понадобится)
+    // Пока не используем напрямую, промис разрешается через старые callbacks
     @objc public init(publicId: String, CPSDK: CloudpaymentsSdkImpl?) {
         self.CPSDK = CPSDK
         self.publicId = publicId
@@ -29,7 +32,6 @@ public class CloudpaymentsPaymentFormService: NSObject {
         resolve: @escaping RCTPromiseResolveBlock,
         reject: @escaping RCTPromiseRejectBlock
     ) {
-
         // Создаем callbacks для конвертации resolve/reject в RCTResponseSenderBlock
       let onSuccess: RCTResponseSenderBlock = { result in
           if let unwrappedResult = result, let resultDict = unwrappedResult.first as? [String: Any] {
@@ -72,6 +74,8 @@ public class CloudpaymentsPaymentFormService: NSObject {
         }
 
       guard let paymentObj = PaymentData(from: paymentData) else {
+          // ПАТЧ: Если не удалось создать PaymentData, реджектим промис через onFailure
+          onFailure([EDefaultMessages.failedToCreatePaymentData.rawValue])
           return
       }
 
@@ -188,43 +192,64 @@ extension CloudpaymentsPaymentFormService: PaymentDelegate {
 
     public func onPaymentFinished(_ transactionId: Int64?) {
         DispatchQueue.main.async { [weak self] in
+            guard let self = self else { return }
+            
             let result: [String: Any] = [
                 EResponseKeys.success.rawValue: true,
                 EResponseKeys.transactionId.rawValue: transactionId ?? EDefaultValues.defaultTransactionId,
                 EResponseKeys.message.rawValue: EDefaultMessages.paymentCompletedSuccessfully.rawValue
             ]
-          self?.CPSDK?.sendEvent(name: EPaymentFormEventName.paymentForm.rawValue, data: [
-             EPaymentFormAction.action.rawValue: EPaymentFormAction.transaction.rawValue,
-              EResponseKeys.statusCode.rawValue: true,
-              EResponseKeys.transactionId.rawValue: transactionId as Any
-          ])
-            self?.onPaymentSuccess?([result])
-            self?.cleanup()
+            
+            // Отправляем событие
+            self.CPSDK?.sendEvent(name: EPaymentFormEventName.paymentForm.rawValue, data: [
+               EPaymentFormAction.action.rawValue: EPaymentFormAction.transaction.rawValue,
+                EResponseKeys.statusCode.rawValue: true,
+                EResponseKeys.transactionId.rawValue: transactionId as Any
+            ])
+            
+            // ПАТЧ: Вызываем старый callback, который разрешит промис через onSuccess
+            // Это сохраняет оригинальную логику работы событий
+            self.onPaymentSuccess?([result])
+            self.cleanup()
         }
     }
 
     public func onPaymentFailed(_ errorMessage: String?) {
         DispatchQueue.main.async { [weak self] in
+            guard let self = self else { return }
+            
             let error = errorMessage ?? EDefaultMessages.paymentFailed.rawValue
-          self?.CPSDK?.sendEvent(name: EPaymentFormEventName.paymentForm.rawValue, data: [
-             EPaymentFormAction.action.rawValue: EPaymentFormAction.transaction.rawValue,
-              EResponseKeys.statusCode.rawValue: false,
-              EResponseKeys.message.rawValue: errorMessage ?? EDefaultMessages.unknownError.rawValue
-          ])
-            self?.onPaymentFailure?([error])
-            self?.cleanup()
+            
+            // Отправляем событие
+            self.CPSDK?.sendEvent(name: EPaymentFormEventName.paymentForm.rawValue, data: [
+               EPaymentFormAction.action.rawValue: EPaymentFormAction.transaction.rawValue,
+                EResponseKeys.statusCode.rawValue: false,
+                EResponseKeys.message.rawValue: errorMessage ?? EDefaultMessages.unknownError.rawValue
+            ])
+            
+            // ПАТЧ: Вызываем старый callback, который реджектит промис через onFailure
+            // Это сохраняет оригинальную логику работы событий
+            self.onPaymentFailure?([error])
+            self.cleanup()
         }
     }
 
     public func onPaymentClosed() {
         DispatchQueue.main.async { [weak self] in
-            // Платеж был закрыт пользователем без завершения
-          self?.CPSDK?.sendEvent(name: EPaymentFormEventName.paymentForm.rawValue, data: [
+            guard let self = self else { return }
+            
+            // Отправляем событие
+            self.CPSDK?.sendEvent(name: EPaymentFormEventName.paymentForm.rawValue, data: [
               EPaymentFormAction.action.rawValue: EPaymentFormAction.transaction.rawValue,
                 EResponseKeys.statusCode.rawValue: false,
                 EResponseKeys.message.rawValue: "Payment closed by user"
           ])
-            self?.cleanup()
+            
+            // ПАТЧ: Вызываем onPaymentFailure для реджекта промиса через старый callback
+            // Это сохраняет оригинальную логику работы событий
+            let cancelMessage = "Payment cancelled by user"
+            self.onPaymentFailure?([cancelMessage])
+            self.cleanup()
         }
     }
 
@@ -248,7 +273,11 @@ extension CloudpaymentsPaymentFormService: PaymentUIDelegate {
 
     public func paymentFormDidHide() {
       CPSDK?.sendEvent(name: EPaymentFormEventName.paymentForm.rawValue, data: [EPaymentFormAction.action.rawValue: EPaymentFormEvent.didHide.rawValue])
-        cleanup()
+      
+      // ПАТЧ: НЕ разрешаем промис здесь, так как paymentFormDidHide вызывается при смене модалок
+      // внутри процесса оплаты (например, переход от выбора способа оплаты к форме ввода карты).
+      // Промис должен разрешаться только в onPaymentFinished, onPaymentFailed или onPaymentClosed.
+      // cleanup() не вызываем здесь, чтобы не очищать resolve/reject до завершения процесса оплаты
     }
 }
 
diff --git a/node_modules/@lmapp/react-native-cloudpayments/src/NativeCloudpaymentsSdk.ts b/node_modules/@lmapp/react-native-cloudpayments/src/NativeCloudpaymentsSdk.ts
index d98c1f8..ba241c1 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/src/NativeCloudpaymentsSdk.ts
+++ b/node_modules/@lmapp/react-native-cloudpayments/src/NativeCloudpaymentsSdk.ts
@@ -33,4 +33,6 @@ export interface Spec extends TurboModule {
   getBankInfo(cardNumber: string): Promise<Object>;
 }
 
-export default TurboModuleRegistry.getEnforcing<Spec>('CloudpaymentsSdk');
+const CloudpaymentsSdkModule = TurboModuleRegistry.getEnforcing<Spec>('CloudpaymentsSdk');
+
+export default CloudpaymentsSdkModule;
diff --git a/node_modules/@lmapp/react-native-cloudpayments/src/hooks/core/useCloudPaymentsEvents.ts b/node_modules/@lmapp/react-native-cloudpayments/src/hooks/core/useCloudPaymentsEvents.ts
index 01bf665..93354a7 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/src/hooks/core/useCloudPaymentsEvents.ts
+++ b/node_modules/@lmapp/react-native-cloudpayments/src/hooks/core/useCloudPaymentsEvents.ts
@@ -237,7 +237,7 @@ export const useCloudPaymentsEvents = (
           break;
 
         default:
-          console.warn('Неизвестное действие платежной формы:', event.action);
+          console.warn('Unknown action:', event.action);
       }
     },
     [setStatus, setError, onSuccess, onError, onCancel]
@@ -257,9 +257,14 @@ export const useCloudPaymentsEvents = (
     enabledEvents.forEach((eventName) => {
       switch (eventName) {
         case EPaymentFormEventName.PAYMENT_FORM:
-          subscriptions.push(
-            eventEmitter.addListener(eventName, handlePaymentFormEvent)
-          );
+          try {
+            const subscription = eventEmitter.addListener(eventName, (event) => {
+              handlePaymentFormEvent(event);
+            });
+            subscriptions.push(subscription);
+          } catch (error) {
+            console.error('Failed to add listener:', error);
+          }
           break;
 
         case EPaymentFormEventName.PAYMENT:
diff --git a/node_modules/@lmapp/react-native-cloudpayments/src/hooks/payment/usePaymentForm.ts b/node_modules/@lmapp/react-native-cloudpayments/src/hooks/payment/usePaymentForm.ts
index 07b49d1..2d0a5d5 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/src/hooks/payment/usePaymentForm.ts
+++ b/node_modules/@lmapp/react-native-cloudpayments/src/hooks/payment/usePaymentForm.ts
@@ -93,11 +93,12 @@ export const usePaymentForm = (
           error instanceof Error ? error.message : 'Неизвестная ошибка';
 
         // Возвращаем результат с ошибкой
-        return {
+        const errorResult = {
           success: false,
           message: errorMessage,
           transactionId: undefined,
         };
+        return errorResult;
       }
     },
     [publicId]
diff --git a/node_modules/@lmapp/react-native-cloudpayments/src/hooks/useCloudPayments.ts b/node_modules/@lmapp/react-native-cloudpayments/src/hooks/useCloudPayments.ts
index ed94e54..0b847ed 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/src/hooks/useCloudPayments.ts
+++ b/node_modules/@lmapp/react-native-cloudpayments/src/hooks/useCloudPayments.ts
@@ -11,6 +11,7 @@ import type {
   IUseCloudPaymentsOptions,
   TUseCloudPaymentsReturn,
 } from './types';
+import {useEffect} from "react";
 
 // ============================================================================
 // HOOK IMPLEMENTATION
@@ -127,6 +128,7 @@ export const useCloudPayments = (
     onCancel,
   });
 
+
   // Хук для платежной формы
   const presentPaymentForm = usePaymentForm(publicId);
 
diff --git a/node_modules/@lmapp/react-native-cloudpayments/src/services/paymentService.ts b/node_modules/@lmapp/react-native-cloudpayments/src/services/paymentService.ts
index e6e3ce8..8c72835 100644
--- a/node_modules/@lmapp/react-native-cloudpayments/src/services/paymentService.ts
+++ b/node_modules/@lmapp/react-native-cloudpayments/src/services/paymentService.ts
@@ -49,7 +49,12 @@ export const PaymentService: IPaymentService = {
   },
 
   //@ts-ignore
-  presentPaymentForm(paymentData: IPaymentData) {
-    return CloudpaymentsSdk.presentPaymentForm(paymentData);
+  async presentPaymentForm(paymentData: IPaymentData) {
+    try {
+      const result = await CloudpaymentsSdk.presentPaymentForm(paymentData);
+      return result;
+    } catch (error) {
+      throw error;
+    }
   },
 };
